{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs nique t aleres For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs-nique-t-aleres","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs nique t aleres"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Bt/","text":"Py Trees for ROS S\u00e9quence La sequence va executer ses enfants un \u00e0 un dans un ordre pr\u00e9d\u00e9finit, si un enfant lui renvoi SUCCESS alors il passe \u00e0 l'autre, si tous les enfant renvoient SUCESS alors il renvoi SUCCESS, si un enfants renvoient FAILURE alors il arrete la s\u00e9quence et renvoi FAILURE Selector { align=left } L'objetif ici est le suivant, dans un premeier temps nous allons verifier que nous avons pas deja un goal en attente, si c'est la cas on peut aller generer la trajectoire pour atteindre notre goal. En revanche si nous avons pas de goal present alors nous pouvons rester en attente de goal avant de poursuivre ############################################################################## # Imports ############################################################################## import functools import py_trees import py_trees_ros import py_trees.console as console +- import rospy import sys from geometry_msgs.msg import PoseStamped import geometry_msgs.msg as geometry_msgs import mbf_msgs.msg as mbf_msgs ############################################################################## # Actions ############################################################################## class GetPath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): self . action_goal = mbf_msgs . GetPathGoal ( target_pose = py_trees . blackboard . Blackboard () . get ( \"target_pose\" )) super ( GetPath , self ) . initialise () def update ( self ): status = super ( GetPath , self ) . update () if status == py_trees . Status . SUCCESS : py_trees . blackboard . Blackboard () . set ( \"path\" , self . action_client . get_result () . path ) return status class ExePath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): self . action_goal = mbf_msgs . ExePathGoal ( path = py_trees . blackboard . Blackboard () . get ( \"path\" )) super ( ExePath , self ) . initialise () ############################################################################## # Behaviours ############################################################################## def create_root (): # Create all behaviours bt_root = py_trees . composites . Sequence ( \"MBF BT Demo\" ) get_goal = py_trees . composites . Selector ( \"GetGoal\" ) fallback = py_trees . composites . Selector ( \"Fallback\" ) navigate = py_trees . composites . Sequence ( \"Navigate\" ) new_goal = py_trees_ros . subscribers . ToBlackboard ( name = \"NewGoal\" , topic_name = \"/move_base_simple/goal\" , topic_type = geometry_msgs . PoseStamped , blackboard_variables = { 'target_pose' : None }) have_goal = py_trees . blackboard . CheckBlackboardVariable ( name = \"HaveGoal\" , variable_name = \"target_pose\" ) clr_goal1 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) clr_goal2 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) get_path = GetPath ( name = \"GetPath\" , action_namespace = \"/move_base_flex/get_path\" , action_spec = mbf_msgs . GetPathAction ) exe_path = ExePath ( name = \"ExePath\" , action_namespace = \"/move_base_flex/exe_path\" , action_spec = mbf_msgs . ExePathAction ) # Compose tree bt_root . add_children ([ get_goal , fallback ]) get_goal . add_children ([ have_goal , new_goal ]) navigate . add_children ([ get_path , exe_path , clr_goal1 ]) fallback . add_children ([ navigate , clr_goal2 ]) return bt_root def shutdown ( behaviour_tree ): behaviour_tree . interrupt () if __name__ == '__main__' : rospy . init_node ( \"mbf_bt_demo\" ) root = create_root () behaviour_tree = py_trees_ros . trees . BehaviourTree ( root ) rospy . on_shutdown ( functools . partial ( shutdown , behaviour_tree )) if not behaviour_tree . setup ( timeout = 15 ): console . logerror ( \"failed to setup the tree, aborting.\" ) sys . exit ( 1 ) behaviour_tree . tick_tock ( 500 ) niquzta elere deded","title":"Behavior Tree"},{"location":"Bt/#py-trees-for-ros","text":"","title":"Py Trees for ROS"},{"location":"Bt/#sequence","text":"La sequence va executer ses enfants un \u00e0 un dans un ordre pr\u00e9d\u00e9finit, si un enfant lui renvoi SUCCESS alors il passe \u00e0 l'autre, si tous les enfant renvoient SUCESS alors il renvoi SUCCESS, si un enfants renvoient FAILURE alors il arrete la s\u00e9quence et renvoi FAILURE","title":"S\u00e9quence"},{"location":"Bt/#selector","text":"{ align=left } L'objetif ici est le suivant, dans un premeier temps nous allons verifier que nous avons pas deja un goal en attente, si c'est la cas on peut aller generer la trajectoire pour atteindre notre goal. En revanche si nous avons pas de goal present alors nous pouvons rester en attente de goal avant de poursuivre ############################################################################## # Imports ############################################################################## import functools import py_trees import py_trees_ros import py_trees.console as console +- import rospy import sys from geometry_msgs.msg import PoseStamped import geometry_msgs.msg as geometry_msgs import mbf_msgs.msg as mbf_msgs ############################################################################## # Actions ############################################################################## class GetPath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): self . action_goal = mbf_msgs . GetPathGoal ( target_pose = py_trees . blackboard . Blackboard () . get ( \"target_pose\" )) super ( GetPath , self ) . initialise () def update ( self ): status = super ( GetPath , self ) . update () if status == py_trees . Status . SUCCESS : py_trees . blackboard . Blackboard () . set ( \"path\" , self . action_client . get_result () . path ) return status class ExePath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): self . action_goal = mbf_msgs . ExePathGoal ( path = py_trees . blackboard . Blackboard () . get ( \"path\" )) super ( ExePath , self ) . initialise () ############################################################################## # Behaviours ############################################################################## def create_root (): # Create all behaviours bt_root = py_trees . composites . Sequence ( \"MBF BT Demo\" ) get_goal = py_trees . composites . Selector ( \"GetGoal\" ) fallback = py_trees . composites . Selector ( \"Fallback\" ) navigate = py_trees . composites . Sequence ( \"Navigate\" ) new_goal = py_trees_ros . subscribers . ToBlackboard ( name = \"NewGoal\" , topic_name = \"/move_base_simple/goal\" , topic_type = geometry_msgs . PoseStamped , blackboard_variables = { 'target_pose' : None }) have_goal = py_trees . blackboard . CheckBlackboardVariable ( name = \"HaveGoal\" , variable_name = \"target_pose\" ) clr_goal1 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) clr_goal2 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) get_path = GetPath ( name = \"GetPath\" , action_namespace = \"/move_base_flex/get_path\" , action_spec = mbf_msgs . GetPathAction ) exe_path = ExePath ( name = \"ExePath\" , action_namespace = \"/move_base_flex/exe_path\" , action_spec = mbf_msgs . ExePathAction ) # Compose tree bt_root . add_children ([ get_goal , fallback ]) get_goal . add_children ([ have_goal , new_goal ]) navigate . add_children ([ get_path , exe_path , clr_goal1 ]) fallback . add_children ([ navigate , clr_goal2 ]) return bt_root def shutdown ( behaviour_tree ): behaviour_tree . interrupt () if __name__ == '__main__' : rospy . init_node ( \"mbf_bt_demo\" ) root = create_root () behaviour_tree = py_trees_ros . trees . BehaviourTree ( root ) rospy . on_shutdown ( functools . partial ( shutdown , behaviour_tree )) if not behaviour_tree . setup ( timeout = 15 ): console . logerror ( \"failed to setup the tree, aborting.\" ) sys . exit ( 1 ) behaviour_tree . tick_tock ( 500 ) niquzta elere deded","title":"Selector"},{"location":"MultiMachine/","text":"Communication Multimachine En robotique il est souvent n\u00e9cessaire d'avoir plusieurs machines qui communiquent entre elles. Dans notre cas nous avons un robot mobile qui doit communiquer avec une console d\u00e9port\u00e9e Il existe plusieurs fa\u00e7ons de communiquer entre machines avec ROS Nous allons d\u00e9crire quelqu'une de ces m\u00e9thodes en pr\u00e9sentant leurs avantages et inconv\u00e9nients Dans toutes ces m\u00e9thodes des machines partage le m\u00eame r\u00e9seau. 1. Utilisation d'une machine \"ma\u00eetre\" La m\u00e9thode la plus simple et d'utiliser un master unique partag\u00e9 par plusieurs machines. Nous avons une machine \"ma\u00eetre\" qui partage son master avec des machines \"escalves\". Commande: Au niveau de la machine ma\u00eetre, dans un terminal: export ROS_HOSTNAME={IP MAITRE} export ROS_MASTER_URI=http://{IP MAITRE}:11311 Au niveau de la machine esclave, dans un terminal: export ROS_HOSTNAME={IP ESCLAVE} export ROS_MASTER_URI=http://{IP MAITRE}:11311 Exemple: Prenons un exemple, nous avons deux machine, un robot et une console, d'adresse IP respective suivante : 192.168.1.1 et 192.168.1.2 Ici, on utilise le master de la console. Au niveau de la console, dans un terminal: export ROS_HOSTNAME=192.168.1.1 export ROS_MASTER_URI=http://192.168.1.1:11311 Au niveau du robot, dans un terminal: export ROS_HOSTNAME=192.168.1.2 export ROS_MASTER_URI=http://192.168.1.1:11311 Ainsi les deux machines partage le m\u00eame master et peuvent donc echanger des topics. Avantage Cette m\u00e9thode et simple et rapide \u00e0 mettre en place. Inconveniants Le probl\u00e8me est l'ulisation d'un master unique. En effet si une machine \"esclave\" pert la connection avec la machine \"ma\u00eetre\" alors elle pert le master et ne peut donc plus utiliser les nodes ROS. Dans notre cas si le robot s'eloigne de notre console est se deconnecte alors il ne pourra plus utiliser ROS. 2. Utilisation de la classe c++ ros::master Cette m\u00e9thode plus compliqu\u00e9 mais elle permet d'utiliser plusieurs master. Pour cela une machine se connecte au master d'une machine \"cible\" souscrit a un topic et publie une copie de ce m\u00eame topic dans son environement local (master local) Il existe une methode de la classe ros, ros::master::init() qui peremt de se connecte \u00e0 un autre master dans le m\u00eame reseau. Attention, pour utiliser cette m\u00e9thode il important d'ajouter au niveau de chaque machine dans /etc/hosts les adresses IP des autres machines Exemple de code : dans le code suivant une console se connecte au master d'un robot, souscirt a son topic SCAN et publie une copie de ce topic dans son environnement local. int main ( int argc , char ** argv ) { // On initialse notre node scan_copieur dans l'environnement local ros :: init ( argc , argv , \"scan_copieur\" ); ros :: NodeHandle nh ; // on cr\u00e9er un objet de notre classe PublisherLocal, on appel ainsi le constructeur qui cr\u00e9\u00e9 un publisher local PublisherLocal PublisherLocal ; //On declare les deux environemments std :: string robot_master = \"http://192.168.1.4::11311\" ; std :: string console_master = \"http://192.168.1.5::11311\" ; //On cr\u00e9e une varibale map M_string et on insere \u00e0 l'index __master le master auquel on veux se connecter ros :: M_string remappings ; remappings [ \"__master\" ] = robot_master ; //On se connecte au master souhait\u00e9 ros :: master :: init ( remappings ); //On souscrit au topic Scan, ici on souscrit dans l'environnement du robot_master ros :: Subscriber subscriberFeedback = nh . subscribe ( \"/scan\" , 1000 , & PublisherLocal :: callback , & hostTopic ); [....] } class PublisherLocal { public : PublisherLocal (); ~ PublisherLocal (); void callback ( const sensor_msgs :: LaserScan msg ); ros :: Publisher pub ; private : ros :: NodeHandle n ; }; PublisherLocal :: PublisherLocal () { pub = n . advertise < sensor_msgs :: LaserScan > ( \"/scan\" , 1000 ); } PublisherLocal ::~ PublisherLocal (){} void PublisherLocal :: callback ( const sensor_msgs :: LaserScan msg ){ if ( ok == 1 ){ oldSeq = msg . header . seq ; ok = 0 ; } else { newSeq = msg . header . seq ; ok = 1 ; } if ( newSeq > oldSeq ) pub . publish ( msg ); } Voir code complet -> [lien git hub] Avantage Cette m\u00e9thode permet d'avoir plus de contr\u00f4les sur la connexion entre machines, elle rend la communication plus flexible. Chaque machine garde son propre master et peut donc \u00eatre ind\u00e9pendante de la connexion r\u00e9seau. Inconveniants La m\u00e9thode est plus complexe et est unidirectionnelle, en effet dans l'exemple pr\u00e9sent\u00e9 pr\u00e9c\u00e9demment, il s'agit d'une lecture et recopie mais pas d'un r\u00e9el \u00e9change de topic. Si plusieurs topics doivent \u00eatre \u00e9chang\u00e9s, il devient fastidieux de r\u00e9aliser une recopie pour chaque topic. 3. Utilisation de ROS Bridge Dans l'exemple suivant nous allons utilis\u00e9 ROS2. L'avantage de ROS2 est que la communication se fait sans Master. Nous allons utliser ROS 2 pour transferer les topic d'une machine ROS1 \u00e0 une autre machine ROS1 Au niveau de la machine 1 export ROS_MASTER_URI=http://192.168.1.4:11311 export ROS_HOSTNAME=192.168.1.4 Au niveau de la machine 2 Premier terminal export ROS_MASTER_URI=http://192.168.1.4:11311 source ROS1 source ROS2 ros2 run ros1_bridge dynamic_bridge --bridge-all-topics Deuxi\u00e8me terminal source ROS1 source ROS2 ros2 run ros1_bridge dynamic_bridge --bridge-all-topics","title":"Multi Machine"},{"location":"MultiMachine/#communication-multimachine","text":"En robotique il est souvent n\u00e9cessaire d'avoir plusieurs machines qui communiquent entre elles. Dans notre cas nous avons un robot mobile qui doit communiquer avec une console d\u00e9port\u00e9e Il existe plusieurs fa\u00e7ons de communiquer entre machines avec ROS Nous allons d\u00e9crire quelqu'une de ces m\u00e9thodes en pr\u00e9sentant leurs avantages et inconv\u00e9nients Dans toutes ces m\u00e9thodes des machines partage le m\u00eame r\u00e9seau.","title":"Communication Multimachine"},{"location":"MultiMachine/#1-utilisation-dune-machine-maitre","text":"La m\u00e9thode la plus simple et d'utiliser un master unique partag\u00e9 par plusieurs machines. Nous avons une machine \"ma\u00eetre\" qui partage son master avec des machines \"escalves\".","title":"1. Utilisation d'une machine \"ma\u00eetre\""},{"location":"MultiMachine/#commande","text":"Au niveau de la machine ma\u00eetre, dans un terminal: export ROS_HOSTNAME={IP MAITRE} export ROS_MASTER_URI=http://{IP MAITRE}:11311 Au niveau de la machine esclave, dans un terminal: export ROS_HOSTNAME={IP ESCLAVE} export ROS_MASTER_URI=http://{IP MAITRE}:11311","title":"Commande:"},{"location":"MultiMachine/#exemple","text":"Prenons un exemple, nous avons deux machine, un robot et une console, d'adresse IP respective suivante : 192.168.1.1 et 192.168.1.2 Ici, on utilise le master de la console. Au niveau de la console, dans un terminal: export ROS_HOSTNAME=192.168.1.1 export ROS_MASTER_URI=http://192.168.1.1:11311 Au niveau du robot, dans un terminal: export ROS_HOSTNAME=192.168.1.2 export ROS_MASTER_URI=http://192.168.1.1:11311 Ainsi les deux machines partage le m\u00eame master et peuvent donc echanger des topics.","title":"Exemple:"},{"location":"MultiMachine/#avantage","text":"Cette m\u00e9thode et simple et rapide \u00e0 mettre en place.","title":"Avantage"},{"location":"MultiMachine/#inconveniants","text":"Le probl\u00e8me est l'ulisation d'un master unique. En effet si une machine \"esclave\" pert la connection avec la machine \"ma\u00eetre\" alors elle pert le master et ne peut donc plus utiliser les nodes ROS. Dans notre cas si le robot s'eloigne de notre console est se deconnecte alors il ne pourra plus utiliser ROS.","title":"Inconveniants"},{"location":"MultiMachine/#2-utilisation-de-la-classe-c-rosmaster","text":"Cette m\u00e9thode plus compliqu\u00e9 mais elle permet d'utiliser plusieurs master. Pour cela une machine se connecte au master d'une machine \"cible\" souscrit a un topic et publie une copie de ce m\u00eame topic dans son environement local (master local) Il existe une methode de la classe ros, ros::master::init() qui peremt de se connecte \u00e0 un autre master dans le m\u00eame reseau. Attention, pour utiliser cette m\u00e9thode il important d'ajouter au niveau de chaque machine dans /etc/hosts les adresses IP des autres machines","title":"2. Utilisation de la classe c++ ros::master"},{"location":"MultiMachine/#exemple-de-code","text":"dans le code suivant une console se connecte au master d'un robot, souscirt a son topic SCAN et publie une copie de ce topic dans son environnement local. int main ( int argc , char ** argv ) { // On initialse notre node scan_copieur dans l'environnement local ros :: init ( argc , argv , \"scan_copieur\" ); ros :: NodeHandle nh ; // on cr\u00e9er un objet de notre classe PublisherLocal, on appel ainsi le constructeur qui cr\u00e9\u00e9 un publisher local PublisherLocal PublisherLocal ; //On declare les deux environemments std :: string robot_master = \"http://192.168.1.4::11311\" ; std :: string console_master = \"http://192.168.1.5::11311\" ; //On cr\u00e9e une varibale map M_string et on insere \u00e0 l'index __master le master auquel on veux se connecter ros :: M_string remappings ; remappings [ \"__master\" ] = robot_master ; //On se connecte au master souhait\u00e9 ros :: master :: init ( remappings ); //On souscrit au topic Scan, ici on souscrit dans l'environnement du robot_master ros :: Subscriber subscriberFeedback = nh . subscribe ( \"/scan\" , 1000 , & PublisherLocal :: callback , & hostTopic ); [....] } class PublisherLocal { public : PublisherLocal (); ~ PublisherLocal (); void callback ( const sensor_msgs :: LaserScan msg ); ros :: Publisher pub ; private : ros :: NodeHandle n ; }; PublisherLocal :: PublisherLocal () { pub = n . advertise < sensor_msgs :: LaserScan > ( \"/scan\" , 1000 ); } PublisherLocal ::~ PublisherLocal (){} void PublisherLocal :: callback ( const sensor_msgs :: LaserScan msg ){ if ( ok == 1 ){ oldSeq = msg . header . seq ; ok = 0 ; } else { newSeq = msg . header . seq ; ok = 1 ; } if ( newSeq > oldSeq ) pub . publish ( msg ); } Voir code complet -> [lien git hub]","title":"Exemple de code :"},{"location":"MultiMachine/#avantage_1","text":"Cette m\u00e9thode permet d'avoir plus de contr\u00f4les sur la connexion entre machines, elle rend la communication plus flexible. Chaque machine garde son propre master et peut donc \u00eatre ind\u00e9pendante de la connexion r\u00e9seau.","title":"Avantage"},{"location":"MultiMachine/#inconveniants_1","text":"La m\u00e9thode est plus complexe et est unidirectionnelle, en effet dans l'exemple pr\u00e9sent\u00e9 pr\u00e9c\u00e9demment, il s'agit d'une lecture et recopie mais pas d'un r\u00e9el \u00e9change de topic. Si plusieurs topics doivent \u00eatre \u00e9chang\u00e9s, il devient fastidieux de r\u00e9aliser une recopie pour chaque topic.","title":"Inconveniants"},{"location":"MultiMachine/#3-utilisation-de-ros-bridge","text":"Dans l'exemple suivant nous allons utilis\u00e9 ROS2. L'avantage de ROS2 est que la communication se fait sans Master. Nous allons utliser ROS 2 pour transferer les topic d'une machine ROS1 \u00e0 une autre machine ROS1","title":"3. Utilisation de ROS Bridge"},{"location":"MultiMachine/#au-niveau-de-la-machine-1","text":"export ROS_MASTER_URI=http://192.168.1.4:11311 export ROS_HOSTNAME=192.168.1.4","title":"Au niveau de la machine 1"},{"location":"MultiMachine/#au-niveau-de-la-machine-2","text":"Premier terminal export ROS_MASTER_URI=http://192.168.1.4:11311 source ROS1 source ROS2 ros2 run ros1_bridge dynamic_bridge --bridge-all-topics Deuxi\u00e8me terminal source ROS1 source ROS2 ros2 run ros1_bridge dynamic_bridge --bridge-all-topics","title":"Au niveau de la machine 2"},{"location":"Nav/","text":"Move base Client <?xml version=\"1.0\"?> <launch> <!-- Base amcl demo --> <include file= \"$(find mbf_advanced)/launch/amcl_demo_base.launch\" /> <!-- Move Base Flex --> <include file= \"$(find mbf_advanced)/launch/mbf_recovery.launch\" /> </launch> Titre : mbf.launch <launch> <!-- Arguments --> <arg name= \"model\" default= \"$(env TURTLEBOT3_MODEL)\" doc= \"model type [burger, waffle, waffle_pi]\" /> <node name= \"move_base_flex\" pkg= \"mbf_costmap_nav\" type= \"mbf_costmap_nav\" required= \"true\" output= \"screen\" clear_params= \"true\" > <rosparam file= \"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"global_costmap\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"local_costmap\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/local_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/global_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_flex_recovery.yaml\" command= \"load\" /> </node> <!-- Launch box into gazebo --> <include file= \"$(find mbf_advanced)/launch/spawn_box.launch\" /> </launch> La premiere etape et de se soscrire au topic poseStamped qui peremt d'envyer un goal et d'envoyer ce goal a move base en utilisant les action de action lib #!/usr/bin/env python import actionlib import rospy import nav_msgs.srv as nav_srvs import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from geometry_msgs.msg import PoseStamped def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) rospy . logdebug ( \"Relaying move_base_simple/goal pose to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if __name__ == '__main__' : rospy . init_node ( \"move_base_relay\" ) # move base flex ation client relays incoming mb goals to mbf mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) # move_base simple topic and action server mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) rospy . on_shutdown ( lambda : mbf_mb_ac . cancel_all_goals ()) rospy . spin () sd Explication du code: mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) On cr\u00e9er un subsciber \"mb_sb\" qui souscit au topic \"move_base_simple/goal\" de type PoseStamped dont le CallBack et la fonction simple_goal_cb mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) On instancit un client mbf_mb_ac qui va se connecter au node (serveur) /move_base_flex avec commme action : /move_base_flex/move_base Le node move_base_flex dispose de plusieur action (fichier source dans /move_base_flex/mbf_abstract_nav/src/move_base_action.cpp) Whatch py_tree doc http://docs.ros.org/en/kinetic/api/py_trees_ros/html/tutorials.html","title":"Navigation"},{"location":"Nav/#move-base-client","text":"<?xml version=\"1.0\"?> <launch> <!-- Base amcl demo --> <include file= \"$(find mbf_advanced)/launch/amcl_demo_base.launch\" /> <!-- Move Base Flex --> <include file= \"$(find mbf_advanced)/launch/mbf_recovery.launch\" /> </launch> Titre : mbf.launch <launch> <!-- Arguments --> <arg name= \"model\" default= \"$(env TURTLEBOT3_MODEL)\" doc= \"model type [burger, waffle, waffle_pi]\" /> <node name= \"move_base_flex\" pkg= \"mbf_costmap_nav\" type= \"mbf_costmap_nav\" required= \"true\" output= \"screen\" clear_params= \"true\" > <rosparam file= \"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"global_costmap\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"local_costmap\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/local_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/global_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_flex_recovery.yaml\" command= \"load\" /> </node> <!-- Launch box into gazebo --> <include file= \"$(find mbf_advanced)/launch/spawn_box.launch\" /> </launch> La premiere etape et de se soscrire au topic poseStamped qui peremt d'envyer un goal et d'envoyer ce goal a move base en utilisant les action de action lib #!/usr/bin/env python import actionlib import rospy import nav_msgs.srv as nav_srvs import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from geometry_msgs.msg import PoseStamped def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) rospy . logdebug ( \"Relaying move_base_simple/goal pose to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if __name__ == '__main__' : rospy . init_node ( \"move_base_relay\" ) # move base flex ation client relays incoming mb goals to mbf mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) # move_base simple topic and action server mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) rospy . on_shutdown ( lambda : mbf_mb_ac . cancel_all_goals ()) rospy . spin () sd Explication du code: mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) On cr\u00e9er un subsciber \"mb_sb\" qui souscit au topic \"move_base_simple/goal\" de type PoseStamped dont le CallBack et la fonction simple_goal_cb mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) On instancit un client mbf_mb_ac qui va se connecter au node (serveur) /move_base_flex avec commme action : /move_base_flex/move_base Le node move_base_flex dispose de plusieur action (fichier source dans /move_base_flex/mbf_abstract_nav/src/move_base_action.cpp) Whatch py_tree doc http://docs.ros.org/en/kinetic/api/py_trees_ros/html/tutorials.html","title":"Move base Client"},{"location":"Setup/","text":"Cr\u00e9ations d\u2018un Workspace que nous allons appeler move_base_ws schema simplifier mkdir moveBase_ws cd moveBase_ws Cr\u00e9ation d\u2019un fichier source: mkdir src Dans source nous allons cr\u00e9er un fichier allons appeler mvb_ws: cd src mkdir mvb_pkg nous allons copier dans notre package les fichier source de navigation sudo git clone https://github.com/ros-planning/navigation.git Il est \u00e9galement possible d\u2019installer les fichier source directement avec apt-get XXXXX nous allons ajouter le paquet turtlebot 3 utilisants move_base sudo git clone https://github.com/ROBOTIS-GIT/turtlebot3.git Enfin nous allons cloner le paquet turtlebot permettant la simulation dans l'environnement 3d gazebo sudo git clone https://github.com/ROBOTIS-GIT/turtlebot3_simulations.git","title":"Setup"},{"location":"Sim/","text":"Dans turtlebot3_navigation -> turtlebot3_gazebo nous avons plusieur environnements de simulation { align=left } Dans launch nous avons les different fichier d'ex\u00e9cution des environnement de simulation Dans model nous avons les modeles 3d de robot et d'\u00e9l\u00e9ment de l\u2019environnement Dans worlds nous avons les different monde 3d Tous les elemeents 3D sont cod\u00e9e en XML dans un format URDF Launch File Pour commencer nous allons lanver une simulation gazebo dans le monde trurtlebot word 3 <launch> <arg name= \"model\" default= \"$(env TURTLEBOT3_MODEL)\" doc= \"model type [burger, waffle, waffle_pi]\" /> <arg name= \"x_pos\" default= \"-2.0\" /> <arg name= \"y_pos\" default= \"-0.5\" /> <arg name= \"z_pos\" default= \"0.0\" /> Ici, le launch file attend un argument \u201cmodel\u201d qui nous laisse le choix entre different modele de robot [burger, waffle, waffle_pi], ces mod\u00e8les sont present dans ls fichier models Les trois arguments suivatn x_pos, y_pos, et z_pos sont la position ou va apparaitre notre robot dans la map <include file= \"$(find gazebo_ros)/launch/empty_world.launch\" > <arg name= \"world_name\" value= \"$(find turtlebot3_gazebo)/worlds/turtlebot3_world.world\" /> <arg name= \"paused\" value= \"false\" /> <arg name= \"use_sim_time\" value= \"true\" /> <arg name= \"gui\" value= \"true\" /> <arg name= \"headless\" value= \"false\" /> <arg name= \"debug\" value= \"false\" /> </include> On inclu le launch file empty_word.launch qui va demarer une simulation, ce launch file prend plusieur argument d\u2019entr\u00e9e comme la map utilis\u00e9, \u201cword_name\u201d ici la valeur de notre argument va chercher un model monde present dans le fichier wordls. l\u2019agument \u201cgui\u201d mis a \u201ctrue\u201d permet de lancer l\u2019interface graphique de la simulation <param name= \"robot_description\" command= \"$(find xacro)/xacro --inorder $(find turtlebot3_description)/urdf/turtlebot3_$(arg model).urdf.xacro\" /> <node pkg= \"gazebo_ros\" type= \"spawn_model\" name= \"spawn_urdf\" args= \"-urdf -model turtlebot3_$(arg model) -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description\" /> </launch> Nous lan\u00e7ons le node spawn_urdf du packet gazebo_ros qui prend comme parametre \u201crobot description\u201d , ce param\u00e8tre pointe vers l\u2019urdf de notre robot ici, si nous choisision le robot burger, l\u2019urdf sera : turtlebot3_burger.urdf.xacro Ce fichier se trouve dans turtlebo3/turtlebot3_description/urdf , il est la description du robot au format URDF, dans l\u2019entete du fichier nous avons deux includes important: URDF <?xml version=\"1.0\" ?> <robot name= \"turtlebot3_burger\" xmlns:xacro= \"http://ros.org/wiki/xacro\" > <xacro:include filename= \"$(find turtlebot3_description)/urdf/common_properties.xacro\" /> <xacro:include filename= \"$(find turtlebot3_description)/urdf/turtlebot3_burger.gazebo.xacro\" /> Le premier, common_properties.xacro permet de definir la couleur des links utilis\u00e9 en code RGB Le deuxieme, turtlebot3_burger.gazebo.xacro, contient les param\u00e8tres physiques appliqu\u00e9 \u00e0 nos joint comme le frotement ou l\u2019inertie et des plugin utilis\u00e9 lors de la simulation. Plugins turtlebot3_burger_controller Il permet de contr\u00f4ler le robot en publiant dasn un topic et de generer une odom\u00e9trie <gazebo> <plugin name= \"turtlebot3_burger_controller\" filename= \"libgazebo_ros_diff_drive.so\" > <commandTopic> cmd_vel </commandTopic> <odometryTopic> odom </odometryTopic> <odometryFrame> odom </odometryFrame> <odometrySource> world </odometrySource> <publishOdomTF> true </publishOdomTF> <robotBaseFrame> base_footprint </robotBaseFrame> <publishWheelTF> false </publishWheelTF> <publishTf> true </publishTf> <publishWheelJointState> true </publishWheelJointState> <legacyMode> false </legacyMode> <updateRate> 30 </updateRate> <leftJoint> wheel_left_joint </leftJoint> <rightJoint> wheel_right_joint </rightJoint> <wheelSeparation> 0.160 </wheelSeparation> <wheelDiameter> 0.066 </wheelDiameter> <wheelAcceleration> 1 </wheelAcceleration> <wheelTorque> 10 </wheelTorque> <rosDebugLevel> na </rosDebugLevel> </plugin> </gazebo> Ici nous pouvons controler le robot en publiant dans \u201ccmd_vel\u201d, le topic odom\u00e9trie et \u201codom\u201d et la transformation ce fait entre \u201codom\u201d et \u201cbase_footprint\u201d gazebo_ros_lds_lfcd_controller Ce plugin permet de simuler un lidar: <plugin name= \"gazebo_ros_lds_lfcd_controller\" filename= \"libgazebo_ros_laser.so\" > <topicName> scan </topicName> <frameName> base_scan </frameName> </plugin> Il gen\u00e8re un topic \u201cscan\u201d dont le nom est definti dans TopicName , le scan ce fait dans le plan definti par le link frameName ici, \u201cbase-scan\u201d. Lancement Nous allons lancer la simulation: On choisi le mod\u00e8le du robot que l\u2019on souhaite parmis la liste suivant [burger, waffle, waffle_pi] export TURTLEBOT3_MODEL=burger On lance la simulation: roslaunch turtlebot3_gazebo turtlebot3_world.launch Voici le r\u00e9sultsat du gui Gazeo","title":"Simultation"},{"location":"Sim/#launch-file","text":"Pour commencer nous allons lanver une simulation gazebo dans le monde trurtlebot word 3 <launch> <arg name= \"model\" default= \"$(env TURTLEBOT3_MODEL)\" doc= \"model type [burger, waffle, waffle_pi]\" /> <arg name= \"x_pos\" default= \"-2.0\" /> <arg name= \"y_pos\" default= \"-0.5\" /> <arg name= \"z_pos\" default= \"0.0\" /> Ici, le launch file attend un argument \u201cmodel\u201d qui nous laisse le choix entre different modele de robot [burger, waffle, waffle_pi], ces mod\u00e8les sont present dans ls fichier models Les trois arguments suivatn x_pos, y_pos, et z_pos sont la position ou va apparaitre notre robot dans la map <include file= \"$(find gazebo_ros)/launch/empty_world.launch\" > <arg name= \"world_name\" value= \"$(find turtlebot3_gazebo)/worlds/turtlebot3_world.world\" /> <arg name= \"paused\" value= \"false\" /> <arg name= \"use_sim_time\" value= \"true\" /> <arg name= \"gui\" value= \"true\" /> <arg name= \"headless\" value= \"false\" /> <arg name= \"debug\" value= \"false\" /> </include> On inclu le launch file empty_word.launch qui va demarer une simulation, ce launch file prend plusieur argument d\u2019entr\u00e9e comme la map utilis\u00e9, \u201cword_name\u201d ici la valeur de notre argument va chercher un model monde present dans le fichier wordls. l\u2019agument \u201cgui\u201d mis a \u201ctrue\u201d permet de lancer l\u2019interface graphique de la simulation <param name= \"robot_description\" command= \"$(find xacro)/xacro --inorder $(find turtlebot3_description)/urdf/turtlebot3_$(arg model).urdf.xacro\" /> <node pkg= \"gazebo_ros\" type= \"spawn_model\" name= \"spawn_urdf\" args= \"-urdf -model turtlebot3_$(arg model) -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description\" /> </launch> Nous lan\u00e7ons le node spawn_urdf du packet gazebo_ros qui prend comme parametre \u201crobot description\u201d , ce param\u00e8tre pointe vers l\u2019urdf de notre robot ici, si nous choisision le robot burger, l\u2019urdf sera : turtlebot3_burger.urdf.xacro Ce fichier se trouve dans turtlebo3/turtlebot3_description/urdf , il est la description du robot au format URDF, dans l\u2019entete du fichier nous avons deux includes important:","title":"Launch File"},{"location":"Sim/#urdf","text":"<?xml version=\"1.0\" ?> <robot name= \"turtlebot3_burger\" xmlns:xacro= \"http://ros.org/wiki/xacro\" > <xacro:include filename= \"$(find turtlebot3_description)/urdf/common_properties.xacro\" /> <xacro:include filename= \"$(find turtlebot3_description)/urdf/turtlebot3_burger.gazebo.xacro\" /> Le premier, common_properties.xacro permet de definir la couleur des links utilis\u00e9 en code RGB Le deuxieme, turtlebot3_burger.gazebo.xacro, contient les param\u00e8tres physiques appliqu\u00e9 \u00e0 nos joint comme le frotement ou l\u2019inertie et des plugin utilis\u00e9 lors de la simulation.","title":"URDF"},{"location":"Sim/#plugins","text":"turtlebot3_burger_controller Il permet de contr\u00f4ler le robot en publiant dasn un topic et de generer une odom\u00e9trie <gazebo> <plugin name= \"turtlebot3_burger_controller\" filename= \"libgazebo_ros_diff_drive.so\" > <commandTopic> cmd_vel </commandTopic> <odometryTopic> odom </odometryTopic> <odometryFrame> odom </odometryFrame> <odometrySource> world </odometrySource> <publishOdomTF> true </publishOdomTF> <robotBaseFrame> base_footprint </robotBaseFrame> <publishWheelTF> false </publishWheelTF> <publishTf> true </publishTf> <publishWheelJointState> true </publishWheelJointState> <legacyMode> false </legacyMode> <updateRate> 30 </updateRate> <leftJoint> wheel_left_joint </leftJoint> <rightJoint> wheel_right_joint </rightJoint> <wheelSeparation> 0.160 </wheelSeparation> <wheelDiameter> 0.066 </wheelDiameter> <wheelAcceleration> 1 </wheelAcceleration> <wheelTorque> 10 </wheelTorque> <rosDebugLevel> na </rosDebugLevel> </plugin> </gazebo> Ici nous pouvons controler le robot en publiant dans \u201ccmd_vel\u201d, le topic odom\u00e9trie et \u201codom\u201d et la transformation ce fait entre \u201codom\u201d et \u201cbase_footprint\u201d gazebo_ros_lds_lfcd_controller Ce plugin permet de simuler un lidar: <plugin name= \"gazebo_ros_lds_lfcd_controller\" filename= \"libgazebo_ros_laser.so\" > <topicName> scan </topicName> <frameName> base_scan </frameName> </plugin> Il gen\u00e8re un topic \u201cscan\u201d dont le nom est definti dans TopicName , le scan ce fait dans le plan definti par le link frameName ici, \u201cbase-scan\u201d.","title":"Plugins"},{"location":"Sim/#lancement","text":"Nous allons lancer la simulation: On choisi le mod\u00e8le du robot que l\u2019on souhaite parmis la liste suivant [burger, waffle, waffle_pi] export TURTLEBOT3_MODEL=burger On lance la simulation: roslaunch turtlebot3_gazebo turtlebot3_world.launch Voici le r\u00e9sultsat du gui Gazeo","title":"Lancement"}]}