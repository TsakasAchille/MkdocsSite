{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs nique t aleres","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Bt/","title":"Py Trees for ROS","text":""},{"location":"Bt/#sequence","title":"S\u00e9quence","text":"<p>La sequence va executer ses enfants un \u00e0 un dans un ordre pr\u00e9d\u00e9finit, si un enfant lui renvoi SUCCESS alors il passe \u00e0 l'autre, si tous les enfant renvoient SUCESS alors il renvoi SUCCESS, si un enfants renvoient FAILURE alors il arrete la s\u00e9quence et renvoi FAILURE</p>"},{"location":"Bt/#selector","title":"Selector","text":"<p>{ align=left }</p> <p>L'objetif ici est le suivant, dans un premeier temps nous allons verifier que nous avons pas deja un goal en attente, si c'est la cas on peut aller generer la trajectoire pour atteindre notre goal. En revanche si nous avons pas de goal present alors nous pouvons rester en attente de goal avant de poursuivre </p> <pre><code>##############################################################################\n# Imports\n##############################################################################\nimport functools\nimport py_trees\nimport py_trees_ros\nimport py_trees.console as console+-\nimport rospy\nimport sys\nfrom geometry_msgs.msg import PoseStamped\nimport geometry_msgs.msg as geometry_msgs\nimport mbf_msgs.msg as mbf_msgs\n##############################################################################\n# Actions\n##############################################################################\nclass GetPath(py_trees_ros.actions.ActionClient):\ndef initialise(self):\nself.action_goal = mbf_msgs.GetPathGoal(target_pose=py_trees.blackboard.Blackboard().get(\"target_pose\"))\nsuper(GetPath, self).initialise()\ndef update(self):\nstatus = super(GetPath, self).update()\nif status == py_trees.Status.SUCCESS:\npy_trees.blackboard.Blackboard().set(\"path\", self.action_client.get_result().path)\nreturn status\nclass ExePath(py_trees_ros.actions.ActionClient):\ndef initialise(self):\nself.action_goal = mbf_msgs.ExePathGoal(path=py_trees.blackboard.Blackboard().get(\"path\"))\nsuper(ExePath, self).initialise()\n##############################################################################\n# Behaviours\n##############################################################################\ndef create_root():\n# Create all behaviours\nbt_root = py_trees.composites.Sequence(\"MBF BT Demo\")\nget_goal = py_trees.composites.Selector(\"GetGoal\")\nfallback = py_trees.composites.Selector(\"Fallback\")\nnavigate = py_trees.composites.Sequence(\"Navigate\")\nnew_goal = py_trees_ros.subscribers.ToBlackboard(name=\"NewGoal\",\ntopic_name=\"/move_base_simple/goal\",\ntopic_type=geometry_msgs.PoseStamped,\nblackboard_variables = {'target_pose': None})\nhave_goal = py_trees.blackboard.CheckBlackboardVariable(name=\"HaveGoal\", variable_name=\"target_pose\")\nclr_goal1 = py_trees.blackboard.ClearBlackboardVariable(name=\"ClearGoal\", variable_name=\"target_pose\")\nclr_goal2 = py_trees.blackboard.ClearBlackboardVariable(name=\"ClearGoal\", variable_name=\"target_pose\")\nget_path = GetPath(name=\"GetPath\",\naction_namespace=\"/move_base_flex/get_path\",\naction_spec=mbf_msgs.GetPathAction)\nexe_path = ExePath(name=\"ExePath\",\naction_namespace=\"/move_base_flex/exe_path\",\naction_spec=mbf_msgs.ExePathAction)\n# Compose tree\nbt_root.add_children([get_goal, fallback])\nget_goal.add_children([have_goal, new_goal])\nnavigate.add_children([get_path, exe_path,clr_goal1])\nfallback.add_children([navigate,clr_goal2 ])\nreturn bt_root\ndef shutdown(behaviour_tree):\nbehaviour_tree.interrupt()\nif __name__ == '__main__':\nrospy.init_node(\"mbf_bt_demo\")\nroot = create_root()\nbehaviour_tree = py_trees_ros.trees.BehaviourTree(root)\nrospy.on_shutdown(functools.partial(shutdown, behaviour_tree))\nif not behaviour_tree.setup(timeout=15):\nconsole.logerror(\"failed to setup the tree, aborting.\")\nsys.exit(1)\nbehaviour_tree.tick_tock(500)\n</code></pre> <p>niquzta elere deded</p>"},{"location":"MultiMachine/","title":"Communication Multimachine","text":"<p>En robotique il est souvent n\u00e9cessaire d'avoir plusieurs machines qui communiquent entre elles. Dans notre cas nous avons un robot mobile qui doit communiquer avec une console d\u00e9port\u00e9e</p> <p>Il existe plusieurs fa\u00e7ons de communiquer entre machines avec ROS</p> <p>Nous allons d\u00e9crire quelqu'une de ces m\u00e9thodes en pr\u00e9sentant leurs avantages et inconv\u00e9nients</p> <p>Dans toutes ces m\u00e9thodes des machines partage le m\u00eame r\u00e9seau. Pour que deux machines puissent communiquer correctement, il est important, dans /etc/hosts,  d'ajouter la ligne suivante:</p>"},{"location":"MultiMachine/#au-niveau-de-la-machine1","title":"Au niveau de la machine1","text":"<pre><code>[IP machinne 1]    [Nom machinne 1]\n</code></pre> <p>exemple:</p> <pre><code>192.168.1.4     robot\n</code></pre>"},{"location":"MultiMachine/#au-niveau-de-la-machine2","title":"Au niveau de la machine2","text":"<pre><code>[IP machinne 2]    [Nom machinne 2]\n</code></pre> <p>exemple:</p> <pre><code>192.168.1.5     console\n</code></pre>"},{"location":"MultiMachine/#1-utilisation-dune-machine-maitre","title":"1. Utilisation d'une machine \"ma\u00eetre\"","text":"<p>La m\u00e9thode la plus simple et d'utiliser un master unique partag\u00e9 par plusieurs machines.</p> <p></p> <p>Nous avons une machine \"ma\u00eetre\" qui partage son master avec des machines \"escalves\".</p>"},{"location":"MultiMachine/#commande","title":"Commande:","text":"<p>Au niveau de la machine ma\u00eetre, dans un terminal:</p> <pre><code>export ROS_HOSTNAME={IP MAITRE}\nexport ROS_MASTER_URI=http://{IP MAITRE}:11311\n</code></pre> <p>Au niveau de la machine esclave, dans un terminal:</p> <pre><code>export ROS_HOSTNAME={IP ESCLAVE}\nexport ROS_MASTER_URI=http://{IP MAITRE}:11311\n</code></pre>"},{"location":"MultiMachine/#exemple","title":"Exemple:","text":"<p>Prenons un exemple, nous avons deux machine, un robot et une console, d'adresse IP respective suivante : 192.168.1.1 et 192.168.1.2 </p> <p></p> <p>Ici, on utilise le master de la console.</p> <p>Au niveau de la console, dans un terminal:</p> <pre><code>export ROS_HOSTNAME=192.168.1.1\nexport ROS_MASTER_URI=http://192.168.1.1:11311\n</code></pre> <p>Au niveau du robot, dans un terminal:</p> <pre><code>export ROS_HOSTNAME=192.168.1.2\nexport ROS_MASTER_URI=http://192.168.1.1:11311\n</code></pre> <p>Ainsi les deux machines partage le m\u00eame master et peuvent donc echanger des topics.</p>"},{"location":"MultiMachine/#avantage","title":"Avantage","text":"<p>Cette m\u00e9thode et simple et rapide \u00e0 mettre en place.</p>"},{"location":"MultiMachine/#inconveniants","title":"Inconveniants","text":"<p>Le probl\u00e8me est l'ulisation d'un master unique. En effet si une machine \"esclave\" pert la connection avec la machine \"ma\u00eetre\" alors elle pert le master et ne peut donc plus utiliser les nodes ROS. Dans notre cas si le robot s'eloigne de notre console est se deconnecte alors il ne pourra plus utiliser ROS.</p>"},{"location":"MultiMachine/#2-utilisation-de-la-classe-c-rosmaster","title":"2. Utilisation de la classe c++ ros::master","text":"<p>Cette m\u00e9thode plus compliqu\u00e9 mais elle permet d'utiliser plusieurs master. Pour cela une machine se connecte au master d'une machine \"cible\" souscrit a un topic et publie une copie de ce m\u00eame topic dans son environement local (master local)</p> <p>Il existe une methode de la classe ros,  <code>ros::master::init()</code>  qui peremt de se connecte \u00e0 un autre master dans le m\u00eame reseau.</p> <p>Attention, pour utiliser cette m\u00e9thode il important d'ajouter au niveau de chaque machine dans <code>/etc/hosts</code> les adresses IP des autres machines</p>"},{"location":"MultiMachine/#exemple-de-code","title":"Exemple de code :","text":"<p>dans le code suivant une console se connecte au master d'un robot, souscirt a son topic SCAN et publie une copie de ce topic dans son environnement local.</p> <pre><code>int main(int argc, char **argv)\n{\n// On initialse notre node scan_copieur dans l'environnement local\nros::init(argc,argv,\"scan_copieur\");\nros::NodeHandle nh;\n// on cr\u00e9er un objet de notre classe PublisherLocal, on appel ainsi le constructeur qui cr\u00e9\u00e9 un publisher local\nPublisherLocal PublisherLocal;\n//On declare les deux environemments\nstd::string robot_master = \"http://192.168.1.4::11311\";\nstd::string console_master= \"http://192.168.1.5::11311\";\n//On cr\u00e9e une varibale map M_string et on insere \u00e0 l'index __master le master auquel on veux se connecter\nros::M_string remappings; remappings[\"__master\"] = robot_master;\n//On se connecte au master souhait\u00e9\nros::master::init(remappings);\n//On souscrit au topic Scan, ici on souscrit dans l'environnement du robot_master\nros::Subscriber subscriberFeedback = nh.subscribe(\"/scan\", 1000, &amp;PublisherLocal::callback, &amp;hostTopic);  [....]\n}\nclass PublisherLocal{\npublic:\nPublisherLocal();\n~PublisherLocal();\nvoid callback(const sensor_msgs::LaserScan msg);    ros::Publisher pub;\nprivate:\nros::NodeHandle n;\n};\nPublisherLocal::PublisherLocal() {\npub = n.advertise&lt;sensor_msgs::LaserScan&gt;(\"/scan\", 1000);\n}\nPublisherLocal::~PublisherLocal(){}\nvoid PublisherLocal::callback(const sensor_msgs::LaserScan msg){ if(ok == 1){\noldSeq = msg.header.seq;\nok = 0;\n}\nelse{\nnewSeq = msg.header.seq;\nok = 1;\n}\nif(newSeq &gt; oldSeq)\npub.publish(msg);\n}\n</code></pre> <p>Voir code complet -&gt; [lien git hub]</p>"},{"location":"MultiMachine/#avantage_1","title":"Avantage","text":"<p>Cette m\u00e9thode permet d'avoir plus de contr\u00f4les sur la connexion entre machines, elle rend la communication plus flexible. Chaque machine garde son propre master et peut donc \u00eatre ind\u00e9pendante de la connexion r\u00e9seau.</p>"},{"location":"MultiMachine/#inconveniants_1","title":"Inconveniants","text":"<p>La m\u00e9thode est plus complexe et est unidirectionnelle, en effet dans l'exemple pr\u00e9sent\u00e9 pr\u00e9c\u00e9demment, il s'agit d'une lecture et recopie mais pas d'un r\u00e9el \u00e9change de topic.</p> <p>Si plusieurs topics doivent \u00eatre \u00e9chang\u00e9s, il devient fastidieux de r\u00e9aliser une recopie pour chaque topic.</p>"},{"location":"MultiMachine/#3-utilisation-de-ros-bridge","title":"3. Utilisation de ROS Bridge","text":"<p>Dans l'exemple suivant nous allons utilis\u00e9 ROS2. L'avantage de ROS2 est que la communication se fait sans Master. Nous allons utliser ROS 2 pour transferer les topic d'une machine ROS1 \u00e0 une autre machine ROS1</p> <p></p>"},{"location":"MultiMachine/#au-niveau-de-la-machine-1","title":"Au niveau de la machine 1","text":"<pre><code>export ROS_MASTER_URI=http://192.168.1.4:11311\nexport ROS_HOSTNAME=192.168.1.4\n</code></pre>"},{"location":"MultiMachine/#au-niveau-de-la-machine-2","title":"Au niveau de la machine 2","text":"<p>Premier terminal</p> <pre><code>export ROS_MASTER_URI=http://192.168.1.4:11311\nsource ROS1\nsource ROS2\nros2 run ros1_bridge dynamic_bridge --bridge-all-topics\n</code></pre> <p>Deuxi\u00e8me terminal</p> <pre><code>source ROS1\nsource ROS2\nros2 run ros1_bridge dynamic_bridge --bridge-all-topics\n</code></pre> <p>Ce script .sh permet d'automatiser la connection</p> <pre><code>export ROS_MASTER_URI=http://192.168.1.4:11311\nsource ${ROS1}\nsource ${ROS2}\ngnome-terminal --tab --command=\"ros2 run ros1_bridge dynamic_bridge --bridge-all-topics\"\nexport ROS_MASTER_URI=http://localhost:11311\n\nsource ${ROS1}\nsource ${ROS2}\ngnome-terminal --tab --command=\"ros2 run ros1_bridge dynamic_bridge --bridge-all-topics\"\nsource ${ROS1}\nsource devel/setup.bash\nroslaunch nodes starting_launch.launch #lancement d'un node dans ROS1 local\n</code></pre>"},{"location":"Nav/","title":"Navigation","text":"<pre><code>source devel/setup.bash\nexport TURTLEBOT3_MODEL=rescue\nroslaunch turtlebot3_gazebo turtlebot3_world.launch\n</code></pre>"},{"location":"Nav/#_1","title":"Navigation","text":"<pre><code>source devel/setup.bash\nexport TURTLEBOT3_MODEL=rescue\nroslaunch mbf_advanced amcl_demo_mbf_recovery.launch\n</code></pre>"},{"location":"Nav/#_2","title":"Navigation","text":"<pre><code>source devel/setup.bash\nrosrun mbf_advanced pytreesRecovery.py\n</code></pre>"},{"location":"Nav/#_3","title":"Navigation","text":"<pre><code>rosrun rqt_py_trees rqt_py_trees\n</code></pre>"},{"location":"Nav/#move-base-client","title":"Move base Client","text":"<p><pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;launch&gt;\n&lt;!-- Base amcl demo --&gt;\n&lt;include file=\"$(find mbf_advanced)/launch/amcl_demo_base.launch\"/&gt;\n&lt;!-- Move Base Flex --&gt;\n&lt;include file=\"$(find mbf_advanced)/launch/mbf_recovery.launch\"/&gt;\n&lt;/launch&gt;\n</code></pre> Titre : mbf.launch</p> <pre><code>&lt;launch&gt;\n&lt;!-- Arguments --&gt;\n&lt;arg name=\"model\" default=\"$(env TURTLEBOT3_MODEL)\" doc=\"model type [burger, waffle, waffle_pi]\"/&gt;\n&lt;node name=\"move_base_flex\" pkg=\"mbf_costmap_nav\" type=\"mbf_costmap_nav\" required=\"true\" output=\"screen\" clear_params=\"true\"&gt;\n&lt;rosparam file=\"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command=\"load\" ns=\"global_costmap\" /&gt;\n&lt;rosparam file=\"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command=\"load\" ns=\"local_costmap\" /&gt;\n&lt;rosparam file=\"$(find turtlebot3_navigation)/param/local_costmap_params.yaml\" command=\"load\" /&gt;\n&lt;rosparam file=\"$(find turtlebot3_navigation)/param/global_costmap_params.yaml\" command=\"load\" /&gt;\n&lt;rosparam file=\"$(find mbf_advanced)/param/move_base_flex_recovery.yaml\" command=\"load\"/&gt;\n&lt;/node&gt;\n&lt;!-- Launch box into gazebo --&gt;\n&lt;include file=\"$(find mbf_advanced)/launch/spawn_box.launch\"/&gt;\n&lt;/launch&gt;\n</code></pre> <p>La premiere etape et de se soscrire au topic poseStamped qui peremt d'envyer un goal et d'envoyer ce goal a move base en utilisant les action de action lib</p> <pre><code>#!/usr/bin/env python\nimport actionlib\nimport rospy\nimport nav_msgs.srv as nav_srvs\nimport mbf_msgs.msg as mbf_msgs\nimport move_base_msgs.msg as mb_msgs\nfrom geometry_msgs.msg import PoseStamped\ndef simple_goal_cb(msg):\nmbf_mb_ac.send_goal(mbf_msgs.MoveBaseGoal(target_pose=msg))\nrospy.logdebug(\"Relaying move_base_simple/goal pose to mbf\")\nmbf_mb_ac.wait_for_result()\nstatus = mbf_mb_ac.get_state()\nresult = mbf_mb_ac.get_result()\nrospy.logdebug(\"MBF execution completed with result [%d]: %s\", result.outcome, result.message)\nif __name__ == '__main__':\nrospy.init_node(\"move_base_relay\")\n# move base flex ation client relays incoming mb goals to mbf\nmbf_mb_ac = actionlib.SimpleActionClient(\"move_base_flex/move_base\", mbf_msgs.MoveBaseAction)\nmbf_mb_ac.wait_for_server(rospy.Duration(20))\n# move_base simple topic and action server\nmb_sg = rospy.Subscriber('move_base_simple/goal', PoseStamped, simple_goal_cb)\nrospy.on_shutdown(lambda: mbf_mb_ac.cancel_all_goals())\nrospy.spin()sd\n</code></pre> <p>Explication du code:</p> <pre><code>mb_sg = rospy.Subscriber('move_base_simple/goal', PoseStamped, simple_goal_cb)\n</code></pre> <p>On cr\u00e9er un subsciber \"mb_sb\" qui souscit au topic \"move_base_simple/goal\" de type PoseStamped dont le CallBack et la fonction simple_goal_cb</p> <pre><code>mbf_mb_ac = actionlib.SimpleActionClient(\"move_base_flex/move_base\", mbf_msgs.MoveBaseAction)\nmbf_mb_ac.wait_for_server(rospy.Duration(20))\n</code></pre> <p>On instancit un client mbf_mb_ac  qui va se connecter au node (serveur) /move_base_flex  avec commme action : /move_base_flex/move_base</p> <p>Le node move_base_flex dispose de plusieur action (fichier source dans /move_base_flex/mbf_abstract_nav/src/move_base_action.cpp)</p> <p>Whatch py_tree doc http://docs.ros.org/en/kinetic/api/py_trees_ros/html/tutorials.html</p>"},{"location":"Plugins/","title":"URDF","text":"<pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;robot name=\"turtlebot3_burger\" xmlns:xacro=\"http://ros.org/wiki/xacro\"&gt;\n&lt;xacro:include filename=\"$(find turtlebot3_description)/urdf/common_properties.xacro\"/&gt;\n&lt;xacro:include filename=\"$(find turtlebot3_description)/urdf/turtlebot3_burger.gazebo.xacro\"/&gt;\n</code></pre> <p>Le premier, common_properties.xacro permet de definir la couleur des links utilis\u00e9 en code RGB</p> <p>Le deuxieme, turtlebot3_burger.gazebo.xacro, contient les param\u00e8tres physiques appliqu\u00e9 \u00e0 nos joint comme le frotement ou l\u2019inertie et des plugin utilis\u00e9 lors de la simulation.</p>"},{"location":"Plugins/#plugins","title":"Plugins","text":"<ul> <li>turtlebot3_burger_controller</li> </ul> <p>Il permet de contr\u00f4ler le robot en publiant dasn un topic et de generer une odom\u00e9trie</p> <pre><code>&lt;gazebo&gt;\n&lt;plugin name=\"turtlebot3_burger_controller\" filename=\"libgazebo_ros_diff_drive.so\"&gt;\n&lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;\n&lt;odometryTopic&gt;odom&lt;/odometryTopic&gt;\n&lt;odometryFrame&gt;odom&lt;/odometryFrame&gt;\n&lt;odometrySource&gt;world&lt;/odometrySource&gt;\n&lt;publishOdomTF&gt;true&lt;/publishOdomTF&gt;\n&lt;robotBaseFrame&gt;base_footprint&lt;/robotBaseFrame&gt;\n&lt;publishWheelTF&gt;false&lt;/publishWheelTF&gt;\n&lt;publishTf&gt;true&lt;/publishTf&gt;\n&lt;publishWheelJointState&gt;true&lt;/publishWheelJointState&gt;\n&lt;legacyMode&gt;false&lt;/legacyMode&gt;\n&lt;updateRate&gt;30&lt;/updateRate&gt;\n&lt;leftJoint&gt;wheel_left_joint&lt;/leftJoint&gt;\n&lt;rightJoint&gt;wheel_right_joint&lt;/rightJoint&gt;\n&lt;wheelSeparation&gt;0.160&lt;/wheelSeparation&gt;\n&lt;wheelDiameter&gt;0.066&lt;/wheelDiameter&gt;\n&lt;wheelAcceleration&gt;1&lt;/wheelAcceleration&gt;\n&lt;wheelTorque&gt;10&lt;/wheelTorque&gt;\n&lt;rosDebugLevel&gt;na&lt;/rosDebugLevel&gt;\n&lt;/plugin&gt;\n&lt;/gazebo&gt;\n</code></pre> <p>Ici nous pouvons controler le robot en publiant dans \u201ccmd_vel\u201d, le topic odom\u00e9trie et \u201codom\u201d et la transformation ce fait entre \u201codom\u201d et \u201cbase_footprint\u201d</p> <ul> <li>gazebo_ros_lds_lfcd_controller</li> </ul> <p>Ce plugin  permet de simuler un lidar: </p> <pre><code> &lt;plugin name=\"gazebo_ros_lds_lfcd_controller\" filename=\"libgazebo_ros_laser.so\"&gt;\n&lt;topicName&gt;scan&lt;/topicName&gt;\n&lt;frameName&gt;base_scan&lt;/frameName&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Il gen\u00e8re un topic \u201cscan\u201d dont le nom est definti dans TopicName,  le scan ce fait dans le plan definti par le link frameName ici,  \u201cbase-scan\u201d.</p>"},{"location":"Setup/","title":"Setup","text":"<p>Cr\u00e9ations d\u2018un Workspace que nous allons appeler move_base_ws</p> <p>schema simplifier </p> <pre><code>mkdir moveBase_ws\ncd moveBase_ws\n</code></pre> <p>Cr\u00e9ation d\u2019un fichier source:</p> <pre><code>mkdir src\n</code></pre> <p>Dans source nous allons cr\u00e9er un fichier  allons appeler mvb_ws:</p> <pre><code>cd src\nmkdir mvb_pkg\n</code></pre> <p>nous allons copier dans notre package les fichier source de navigation</p> <pre><code>sudo git clone https://github.com/ros-planning/navigation.git\n</code></pre> <p>Il est \u00e9galement possible d\u2019installer les fichier source directement avec apt-get     XXXXX</p> <p>nous allons ajouter le paquet turtlebot 3 utilisants move_base</p> <pre><code>sudo git clone https://github.com/ROBOTIS-GIT/turtlebot3.git\n</code></pre> <p>Enfin nous allons cloner le paquet turtlebot permettant la simulation dans l'environnement 3d gazebo </p> <pre><code>sudo git clone https://github.com/ROBOTIS-GIT/turtlebot3_simulations.git\n</code></pre>"},{"location":"Sim/","title":"Launch File","text":"<p>Pour commencer nous allons lanver une simulation gazebo dans le monde trurtlebot word 3</p> <pre><code>    &lt;launch&gt;\n&lt;arg name=\"model\" default=\"$(env TURTLEBOT3_MODEL)\" doc=\"model type [burger, waffle, waffle_pi]\"/&gt;\n&lt;arg name=\"x_pos\" default=\"-2.0\"/&gt;\n&lt;arg name=\"y_pos\" default=\"-0.5\"/&gt;\n&lt;arg name=\"z_pos\" default=\"0.0\"/&gt;\n</code></pre> <p>Ici, le launch file attend un argument \u201cmodel\u201d qui nous laisse le choix entre different modele de robot  [burger, waffle, waffle_pi], ces mod\u00e8les sont present dans ls fichier models</p> <p>Les trois arguments suivatn x_pos, y_pos, et z_pos sont la position ou va apparaitre notre robot dans la map</p> <pre><code>  &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\"&gt;\n&lt;arg name=\"world_name\" value=\"$(find turtlebot3_gazebo)/worlds/turtlebot3_world.world\"/&gt;\n&lt;arg name=\"paused\" value=\"false\"/&gt;\n&lt;arg name=\"use_sim_time\" value=\"true\"/&gt;\n&lt;arg name=\"gui\" value=\"true\"/&gt;\n&lt;arg name=\"headless\" value=\"false\"/&gt;\n&lt;arg name=\"debug\" value=\"false\"/&gt;\n&lt;/include&gt;\n</code></pre> <p>On inclu le launch file empty_word.launch qui va demarer une simulation, ce launch file prend plusieur argument d\u2019entr\u00e9e comme la map utilis\u00e9, \u201cword_name\u201d ici la valeur de notre argument va chercher un model monde present dans le fichier wordls. l\u2019agument \u201cgui\u201d mis a \u201ctrue\u201d permet de lancer l\u2019interface graphique de la simulation</p> <pre><code>    &lt;param name=\"robot_description\" command=\"$(find xacro)/xacro --inorder $(find turtlebot3_description)/urdf/turtlebot3_$(arg model).urdf.xacro\" /&gt;\n&lt;node pkg=\"gazebo_ros\" type=\"spawn_model\" name=\"spawn_urdf\"  args=\"-urdf -model turtlebot3_$(arg model) -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description\" /&gt;\n&lt;/launch&gt;\n</code></pre> <p>Nous lan\u00e7ons le node spawn_urdf du packet gazebo_ros qui prend comme parametre \u201crobot description\u201d , ce param\u00e8tre pointe vers l\u2019urdf de notre robot ici, si nous choisision le robot burger, l\u2019urdf sera : turtlebot3_burger.urdf.xacro</p> <p>Ce fichier se trouve dans turtlebo3/turtlebot3_description/urdf  , il est la description du robot au format URDF, dans l\u2019entete du fichier nous avons deux includes important:</p>"},{"location":"Sim/#lancement","title":"Lancement","text":"<p>Nous allons lancer la simulation:</p> <p>On choisi le mod\u00e8le du robot que l\u2019on souhaite parmis la liste suivant [burger, waffle, waffle_pi]</p> <pre><code>export TURTLEBOT3_MODEL=burger\n</code></pre> <p>On lance la simulation:</p> <pre><code>roslaunch turtlebot3_gazebo turtlebot3_world.launch\n</code></pre> <p>Voici le r\u00e9sultsat du gui Gazeo</p> <p></p>"},{"location":"TF/","title":"TF statique","text":"<p>Notre robot est compos\u00e9 de diff\u00e9rente corps ( flipper, roues, lidar ...) qui disposent chaqun de leur propre coordon\u00e9es. Pour visualiser notre robot dans l'espace il est necessaire de relier ces coorodn\u00e9es entre elles par le biai de transformation (TF).</p> <p>Dans notre cas, les diff\u00e9rents corps sont fixes les un des autres. Pour les relier on parle alors de TF statique. Pour r\u00e9aliser un TF statique nous pouvons utiliser le node robot_state_publisher et joint_state_publisher qui vont lire l'urdf de notre mod\u00e8le et creer les TF entre les different joints.</p>"},{"location":"TF/#launch-file","title":"Launch file","text":"<pre><code>&lt;launch&gt;\n&lt;arg name=\"model\" default=\"$(find rescue_description)/urdf/rescue.xacro\"/&gt;\n&lt;arg name=\"gui\" default=\"true\"/&gt;\n&lt;arg name=\"rvizconfig\" default=\"$(find rescue_description)/launch/urdf.rviz\"/&gt;\n&lt;param name=\"robot_description\" command=\"$(find xacro)/xacro $(arg model)\"/&gt;\n&lt;param name=\"use_gui\" value=\"$(arg gui)\"/&gt;\n&lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher\" type=\"joint_state_publisher\"/&gt;\n&lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\"/&gt;\n&lt;node name=\"rviz\" pkg=\"rviz\" args=\"-d $(arg rvizconfig)\" type=\"rviz\" required=\"true\"/&gt;\n&lt;/launch&gt;\n</code></pre> <p>Lancement du launch file:</p> <pre><code>roslaunch rescue_description display.launch\n</code></pre> <p></p>"},{"location":"URDF/","title":"Mod\u00e8le","text":""},{"location":"URDF/#corps","title":"Corps","text":"<p>Ci-dessous, les dimensions du corps du robot:</p> <p></p>"},{"location":"URDF/#collision","title":"Collision","text":"<p>On genere un rectangle correpondant au corps du robot:</p> <p>L\u2019origine du corps se trouve au centre du rectangle, on souhaite d\u00e9caler cette origine pour la placer au niveau de l\u2019entraxe des roues, on decale donc l\u2019axe x de 0.2 m</p> <p>Sur gazebo il est important de distingu\u00e9 deux param\u00e8tres de g\u00e9om\u00e9trie: Visual et colision. Une g\u00e9ometrie \u201ccollision\u201d elle aura des param\u00e8tre physique et sera donc soumis au frottement, friction, gravit\u00e9.. </p> <pre><code>&lt;collision&gt;\n&lt;origin xyz=\"0.2 0 0.0\" rpy=\"0 0 0\"/&gt;\n&lt;geometry&gt;\n&lt;box size=\"0.6 0.420 0.115\"/&gt;\n&lt;/geometry&gt;\n&lt;/collision&gt;\n</code></pre>"},{"location":"URDF/#visuel","title":"Visuel","text":"<p>Une g\u00e9ometrie \u201cvisual\u201d elle, sera purement visuel. Nous pouvons ajouter un mesh, un fichier 3D format STL que nous avons g\u00e9nerer avec un logicielle de CAO.</p> <pre><code>&lt;visual&gt;\n&lt;origin xyz=\"0.2 0 0.0\" rpy=\"0 0 -1.57\"/&gt;\n&lt;geometry&gt;\n&lt;mesh filename=\"package://rescue_description/meshes/base_link.stl\" scale=\"0.001 0.001 0.001\"/&gt;\n&lt;/geometry&gt;\n&lt;material name=\"light_black\"/&gt;\n&lt;/visual&gt;\n</code></pre>"},{"location":"URDF/#physique","title":"Physique","text":"<p>D\u00e9sormais nous devons definir l\u2019inertie de notre pi\u00e8ce. Notre corps est un rectangle, pour faciliter la t\u00e2che, nous pouvons inclure une macro qui calcul la matrice d\u2019inertie d\u2019un rectangle en fonction de sa masse et ses dimension. On y ajoute egalement l\u2019origine du corp.</p> <pre><code> &lt;xacro:macro name=\"box_inertia\" params=\"m w h d x y z\"&gt;\n&lt;inertial&gt;\n&lt;origin  xyz=\"${x} ${y} ${z}\"  rpy=\"${pi/2} 0 ${pi/2}\"/&gt;     &lt;mass value=\"${m}\"/&gt;\n&lt;inertia ixx=\"${(m/12) * (h*h + d*d)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(m/12) * (w*w + d*d)}\" iyz=\"0.0\" izz=\"${(m/12) * (w*w + h*h)}\"/&gt;\n&lt;/inertial&gt;\n&lt;/xacro:macro&gt;\n</code></pre> <p>Nous pouvons appeler la macro dans la definiton du corps</p> <pre><code>&lt;xacro:box_inertia m=\"1O\" w=\"0.420\" d=\"0.6\" h=\"0.115\" x=\"0.2\" y=\"0\" z=\"0\" /&gt;\n</code></pre> <p></p>"},{"location":"URDF/#roue","title":"Roue","text":"<p>Les roues peuvent \u00eatre representer comme des cylindres. voici leur dimensions:</p> <p></p> <p>On cr\u00e9er un link que l\u2019on appelle Roue_Droite <pre><code>&lt;link name=\"Roue_Droite\"&gt;\n</code></pre></p> <p>On gen\u00e8re un cylindre avec les bonnes dimensions <pre><code>&lt;cylinder length=\"0.0375\" radius=\"0.050\"/&gt;        </code></pre></p> <p>On place l\u2019origine de la pi\u00e8ce en son centre: </p> <pre><code>&lt;origin xyz=\" 0 0 0\" rpy=\"0 0 0\"/&gt;\n</code></pre> <p></p> <p>Pour l'assembler au corps, nous devons cr\u00e9er le joint entre la roue droite et le corps du robot. </p> <pre><code>&lt;joint name=\"Joint_Roue_Droite\" type=\"continuous\"&gt;\n</code></pre> <p>Le joint est de type \"continuous\u201d pour indiquer une rotation autour d\u2019un axe unique</p> <p>On definit les lien de parent\u00e9:</p> <pre><code>&lt;parent link=\"base_link\"/&gt;\n&lt;child link=\"Roue_Droite\"/&gt;\n</code></pre> <p>on definit l\u2019origine du joint</p> <p>Cette origine est la distance entre les origines du link p\u00e8re et m\u00e8re en prenant comme origne fixe celle du p\u00e8re On Sohaite d\u00e9caler la roue par rapport \u00e0 l'origine du corps:</p> <p><pre><code> &lt;origin xyz=\"0 -0.21 -0.065\" rpy=\"0 0 0\"/&gt;\n</code></pre> </p> <p>On remarque que la roue n\u2019est pas orient\u00e9 correctement, il est necessaire de r\u00e9aliser une rotation de 90\u00b0 autour de l\u2019axe x</p> <p></p> <p>rotation de 90\u00b0 = \u03c0/2 = 1.57  autour de l\u2019axe x et decalage en y (epaisseur de la roue): <pre><code> &lt;origin xyz=\"0 -0.2285 -0.065\" rpy=\"-1.57 0 0\"/&gt;\n</code></pre></p> <p>Enfin , on definit l\u2019axe de rotation de notre roue, ici, l\u2019axe z <pre><code> &lt;axis xyz=\"0 0 1\"/&gt;\n</code></pre></p>"},{"location":"URDF/#footprint","title":"Footprint","text":"<p>Le footprint du robot definit l\u2019empreinte du robot dans l\u2019espace. Ce param\u00e8tre permet aux algorithme de navigation de connaitre les dimensions du robot. La d\u00e9limitation se d\u00e9finit en 4 point A,B,C,D</p> <pre><code> footprint: [[A], [B], [C], [D]]\n</code></pre> <p></p> <p>Nous devons choisir des points qui permettent de couvrir l\u2019integralit\u00e9 de l'espace pris par le robot L\u2019origine se base par rapport au base_link definit pr\u00e9c\u00e9demment. Dans l\u2019exemple ci-dessous nous avons represent\u00e9 les 4 points correspondant aux angle du corps du robot</p> <p>Le footprint correspondant est le suivant: <pre><code>footprint: [[-0.1,-0.21], [-0.1,0.21], [0.5,0.21], [0.5,-0.21]]\n</code></pre></p> <p>Pour couvrir le robot et ajouter une zone securit\u00e9 nous allons utilise\u00e9 un footprint l\u00e9g\u00e8rement plus grand:</p> <pre><code>footprint: [[-0.12,-0.23], [-0.12,0.23], [0.52,0.23], [0.52,-0.23]]\n</code></pre>"},{"location":"URDF/#_1","title":"Mod\u00e8le","text":""},{"location":"URDF/#_2","title":"Mod\u00e8le","text":""},{"location":"URDF/#_3","title":"Mod\u00e8le","text":""},{"location":"URDF/#_4","title":"Mod\u00e8le","text":""},{"location":"URDF/#_5","title":"Mod\u00e8le","text":""},{"location":"URDF/#_6","title":"Mod\u00e8le","text":""},{"location":"URDF/#_7","title":"Mod\u00e8le","text":""},{"location":"URDF/#_8","title":"Mod\u00e8le","text":""},{"location":"URDF/#assemblage-complet","title":"Assemblage complet","text":"<p>De la m\u00eame mani\u00e8re que pour les roues et le corps on ajoute a notre modele, les flipper, une roues libre, le lidar et la cam\u00e9ra</p> <p>toue les joints sont des joint fixes enfant du link corps</p>"},{"location":"URDF/#arborescence","title":"arborescence","text":"<ul> <li>corps<ul> <li>roue_droite</li> <li>roue_gauche</li> <li>flipper_droit</li> <li>flipper_gauche</li> <li>roue_libre</li> <li>cam\u00e9ra</li> <li>lidar</li> </ul> </li> </ul> <p>Dans le lien github suivant le mod\u00e8le complet</p> <p>GitHub</p>"},{"location":"odometry/","title":"G\u00e9n\u00e9ralit\u00e9","text":"<p>L'odom\u00e9trie est un moyen d'\u00e9stimer la position d'un v\u00e9hicule en mouvement. Elle est pr\u00e9sente sur la majorit\u00e9 des robots mobiles au moyen d'un ou plusieurs capteurs embarqu\u00e9s premettant la mesure du d\u00e9placement et l'orientation du robot. </p> <p>Le principe repose sur le traitement des mesures acquises par le(s) capteur(s) utilis\u00e9(s) afin dans le but de reconstituer le mouvement global du robot en partant d'une position initiale connue. La reconstitution du mouvement global se fait en int\u00e9grant les d\u00e9placements mesur\u00e9s.</p> <p>Comme mentionn\u00e9 plus haut, l'odometrie peut se baser sur un ou plusieurs capteurs tels que des codeurs incr\u00e9mentaux, des centrale inertielle (IMU) ou encore des cam\u00e9ras (mono, st\u00e9r\u00e9o, RGB-D). En effet, dans le domaine de l'odom\u00e9trie, on retrouve quelques termes comme \"visual odometry\", \"visual inertial odometry\" ou encore \"RGB-D odometry\". </p> <p>En fonction des capteurs utilis\u00e9s, le traitement des mesures peut \u00eatre \"gourmand\" en ressource. De ce fait, l'em</p>"},{"location":"odometry/#visual-odometry","title":"Visual odometry","text":""},{"location":"odometry/#visual-inertial-odometry-vio","title":"Visual Inertial odometry (VIO)","text":""}]}